
<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>测试用例2A：列方向 Subgrid 对齐</title>
  <link rel="stylesheet" href="assets/style.css"/>
  <style>
    /* ========== Page 2A specific styles ========== */
    .grid-root.columns-demo {
      /* Named grid lines + fr + minmax; media queries adjust --cols. */
      --cols: [left-start] minmax(220px, 1fr)
              [left-end main-start] minmax(480px, 2fr)
              [main-end right-start] minmax(280px, 1fr)
              [right-end];
      grid-template-columns: var(--cols);
      /* Gap controlled by toolbar via JS */
    }
    @media (max-width: 900px) {
      .grid-root.columns-demo {
        --cols: [main-start] 1.2fr [main-end right-start] 0.8fr [right-end];
      }
    }
    @media (max-width: 640px) {
      .grid-root.columns-demo {
        --cols: [main-start] 1fr [main-end];
      }
    }

    .header { grid-column: left-start / right-end; background: #f8fafc; }
    .left   { grid-column: left-start / left-end; }
    .main   { grid-column: main-start / main-end; }
    .right  { grid-column: right-start / right-end; }

    /* Subgrid container spanning main + right columns */
    .feature {
      grid-column: main-start / right-end;
      display: grid;
      grid-template-columns: subgrid; /* inherit from parent area (main..right) */
      gap: var(--gap);
      border: 1px dashed #bfdbfe;
      background: #f9fbff;
    }
    .feature .card {
      /* Using borders to show edges clearly */
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 10px;
    }
    /* Cards aligned by NAMED lines */
    .card.a { grid-column: main-start / main-end; }
    .card.b { grid-column: main-end / right-end; }
    /* Mixed numeric placement */
    .card.c { grid-column: 1 / -1; }
    .card.d { grid-column: 1 / span 1; }

    .legend { font-size: 12px; color: #475569; }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="inner">
      <div style="display:flex;justify-content:space-between;gap:12px;align-items:baseline;">
        <div>
          <h1>测试用例2A：列方向 Subgrid 对齐</h1>
          <p>验证子网格在<strong>列方向</strong>继承父网格轨道，并按父级命名网格线对齐。</p>
        </div>
        <div class="note" id="support-note">浏览器支持：检测中…</div>
      </div>
      <div class="pages">
        页面导航：
        <a href="./index.html">2A 列</a> ·
        <a href="./rows-subgrid.html">2B 行</a> ·
        <a href="./both-axes.html">2C 双轴</a>
      </div>
    </div>
  </header>

  <main class="container">
    <section class="toolbar">
      <div class="tool">
        <label for="gap">间隙（gap）：</label>
        <input id="gap" type="range" min="0" max="40" step="1" value="16" />
        <span class="value" id="gap-val">16px</span>
      </div>
      <div class="tool">
        <input id="show-parent" type="checkbox" />
        <label for="show-parent">显示父网格线</label>
      </div>
      <div class="tool">
        <input id="show-sub" type="checkbox" />
        <label for="show-sub">显示子网格线</label>
      </div>
      <div class="tool">
        <button class="btn" id="check">运行对齐校验</button>
        <span class="status" id="check-status">对齐校验：未运行</span>
      </div>
      <div class="tool">
        <button class="btn" id="measure">测量一次重排耗时</button>
        <span class="value" id="time">–</span>
      </div>
    </section>

    <section class="test-area">
      <div class="grid-root columns-demo" id="root">
        <div class="grid-item header">
          <strong>页眉</strong>（跨 3 列）
          <span class="badge">父网格</span>
        </div>

        <div class="grid-item left"><strong>左侧栏</strong><br/>用于观察固定列宽与 fr 列之间的分配。</div>
        <div class="grid-item main"><strong>主内容区</strong><br/>用于对照子网格的对齐效果。</div>
        <div class="grid-item right"><strong>右侧栏</strong><br/>用于对齐参照。</div>

        <div class="panel feature" id="feature">
          <div class="card a"><strong>卡片 A</strong>：使用命名行 <code>main-start / main-end</code> 对齐。</div>
          <div class="card b"><strong>卡片 B</strong>：使用命名行 <code>main-end / right-end</code> 对齐。</div>
          <div class="card c"><strong>卡片 C</strong>：使用数字 <code>1 / -1</code> 跨越子网格全部列。</div>
          <div class="card d"><strong>卡片 D</strong>：使用 <code>1 / span 1</code> 占据子网格首列。</div>
        </div>
      </div>
      <p class="legend">提示：缩放窗口宽度以触发媒体查询（≥900px 为三列；640–900px 为两列；≤640px 为一列）。</p>
    </section>

    <section class="explain">
      <h2>解释说明</h2>
      <div class="kv">
        <div>测试目标</div>
        <div>验证 Chrome 对 CSS Subgrid 在<strong>列方向</strong>的继承与对齐：子网格内部元素的边缘应与父网格的列线重合。</div>

        <div>测试方案</div>
        <div>父网格定义 3 列并命名网格线（含固定宽度与 <code>fr</code>）。子容器 <code>.feature</code> 跨越父网格的 <code>main-start</code> 到 <code>right-end</code>，并设置 <code>grid-template-columns: subgrid</code> 继承列轨道；内部卡片分别用「命名行」「数字索引」「跨越」等方式对齐。</div>

        <div>使用方法</div>
        <div>
          1) 勾选“显示父网格线/子网格线”观察线条是否重合；
          2) 调整 gap；3) 缩放窗口触发媒体查询；
          4) 点击“运行对齐校验”自动比对子网格线与父网格线；
          5) “测量一次重排耗时”会在改变 gap 后估计一次性重排的耗时（仅用于粗略参考）。
        </div>

        <div>评估结果</div>
        <div>正常情况下：子网格线与父网格线完全重合；内部卡片的左/右边应落在子网格线位置；在不同视口下，子网格始终随父网格变化保持对齐。</div>
      </div>
    </section>
  </main>

  <script src="assets/app.js"></script>
  <script>
    // Page bootstrap
    const { $, GridOverlay, supportsSubgrid, bindGap, measureReflow, checkSubgridColumnsAlign } = window.GridHarness;
    const root = $('#root');
    const feature = $('#feature');

    // Feature detection
    const ok = supportsSubgrid();
    $('#support-note').textContent = ok ? '浏览器支持：Subgrid ✓' : '浏览器支持：Subgrid ✗（本页功能受限）';
    $('#support-note').style.color = ok ? '#0a7f49' : '#c12a2a';

    // Gap control
    bindGap($('#gap'), root, $('#gap-val'));

    // Overlays
    const ovParent = new GridOverlay(root, 'columns', { useSubgrid: false });
    const ovChild  = new GridOverlay(feature, 'columns', { useSubgrid: true });
    ovParent.setEnabled(false);
    ovChild.setEnabled(false);

    $('#show-parent').addEventListener('change', e => ovParent.setEnabled(e.target.checked));
    $('#show-sub').addEventListener('change', e => ovChild.setEnabled(e.target.checked));

    // Alignment check
    $('#check').addEventListener('click', () => {
      checkSubgridColumnsAlign(root, feature, $('#check-status'));
    });

    // Simple reflow timing: change gap slightly and restore
    const measureBtn = $('#measure');
    measureBtn.addEventListener('click', async () => {
      const prev = parseFloat(getComputedStyle(root).gap) || 16;
      const delta = (prev % 2 === 0) ? 1 : -1;
      const ms = await measureReflow(() => {
        root.style.gap = (prev + delta) + 'px';
      }, root);
      $('#time').textContent = ms.toFixed(2) + ' ms';
      // revert
      root.style.gap = prev + 'px';
    });
  </script>
</body>
</html>
